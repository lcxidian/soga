1、何为定义与声明
定义————就是(编译器)创建一个对象，为这个对象分配一块内存并给它取上一个名字，这个名字就是我们经常所说的变量名或对象名。

声明————第一重含义：告诉编译器，这个名字已经匹配到一块内存上了，下面的代码用到变量或对象是在别的地方定义的。声明可以出现多次。
		第二重含义：告诉编译器，我这个名字我先预定了，别的地方再也不能用它来作为变量名或对象名。


2、register
register：这个关键字请求编译器尽可能的将变量存在CPU 内部寄存器中而不是通过内存寻址访问以提高效率
			register 变量必须是一个单个的值，并且其长度应小于或等于整型的长度。而且register 变量可能不存放在内存中，所以不能用取址运算符“&”来获取register 变量的地址。
#注：数据从内存里拿出来先放到寄存器，然后CPU 再从寄存器里读取数据来处理，处理完后同样把数据通过寄存器存放到内存里，CPU 不直接和内存打交道。
3、static
第一个作用：修饰变量。变量又分为局部和全局变量，但它们都存在内存的静态区。
	静态全局变量，作用域仅限于变量被定义的文件中，其他文件即使用extern 声明也没法使用他。
	静态局部变量，在函数体里面定义的，就只能在这个函数里用了，同一个文档中的其他函数也用不了。
	（生命周期都相同！！！）
第二个作用：修饰函数。函数前加static 使得函数成为静态函数。指对函数的作用域仅局限于本文件(所以又称内部函数)。使用内部函数的好处是：不同的人编写不同的函数时，不用担心自己定义的函数，是否会与其它文件中的函数同名。
C++里对static 赋予了第三个作用：

4、sizeof关键字————计算对象所占内存空间大小，括号可以省略，而计算数据类型大小时不能省略。
#左值————
	在这个上下文环境中，编译器认为x 的含义是x 所代表的地址。这个地址只有编译器知道，
在编译的时候确定，编译器在一个特定的区域保存这个地址，我们完全不必考虑这个地址保存
在哪里。
#右值————
	在这个上下文环境中，编译器认为y 的含义是y 所代表的地址里面的内容。这个内容是什
么，只有到运行时才知道。
	简单地说，出现在赋值符“=”右边的就是右值，出现在赋值符“=”左边的就是左值。比如,x=y。

A),sizeof(int)； 
B)，sizeof(i)； 
C)，sizeof int；#错误，计算数据类型大小时不能省略 
D)，sizeof i；
如：
int main()
{
    int *p = nullptr;
    int a[100];
    cout<<sizeof(*p)<<endl; #4
    cout<<sizeof(a)<<endl; #400
    cout<<sizeof(a[100])<<endl; #4
    cout<<sizeof(&a)<<endl; #4      &a为数组的首地址
    cout<<sizeof(&a[0])<<endl; #4
    return 0;
}

	当a 作为右值的时候代表的是什么意思呢？很多书认为是数组的首地址，其实这是非常
错误的。a 作为右值时其意义与&a[0]是一样，代表的是数组首元素的首地址;a 不能作为
左值！这个错误几乎每一个学生都犯过。

特别注意：&a[0]为数组首元素的首地址
		  &a为数组的首地址 #指向整个数组
		  而a作为右值时，也代表数组首元素的首地址 #指向数组的第一个元素
		  	a不能为左值，因为从来没有数组a被赋值的道理
		  #注：&a和a，其值相同但意义不同。
易错：
int main()
{
    char *p = "12345";
    char a[] = "abcde";
    cout<<sizeof(p)<<endl;# 4，p为指针
    cout<<sizeof(*p)<<endl;# 1

    cout<<sizeof(a)<<endl;# 6 a是数组
    cout<<sizeof(*a)<<endl;# 1
    return 0;
}
特别注意：由于“"12345"”是常量，故存放在静态区，空间大小为7 byte，最后1byte为字符串结束符'\0'
		  char a[] = "abcde";代表把常量字符串"abcde"拷贝给字符数组，并自动给字符数组末尾多分配一个字节，用于存放字符串结束符'\0'
为了验证p指向的空间大小是6:
int main()
{
    char *p = "12345";
    cout<<*p<<endl;
    cout<<*(p+1)<<endl;
    cout<<*(p+2)<<endl;
    cout<<*(p+3)<<endl;
    cout<<*(p+4)<<endl;
    cout<<*(p+5)<<endl;
    cout<<"hello"<<endl;
    return 0;
}
执行结果：	1
			2
			3
			4
			5

			hello
			
引申：在静态区存放12345之后的空间，存放的是hello
如：
int main()
{
    char *p = "12345";
    cout<<*p<<endl;
    cout<<*(p+1)<<endl;
    cout<<*(p+2)<<endl;
    cout<<*(p+3)<<endl;
    cout<<*(p+4)<<endl;
    cout<<*(p+5)<<endl;
    cout<<"hello"<<endl;
    return 0;
}
执行结果：	1
			2
			3
			4
			5

			h
			hello

如：
	int main()
	{
	int a[5]={1,2,3,4,5};
	int *ptr=(int *)(&a+1);
	printf("%d,%d",*(a+1),*(ptr-1));
	}
执行结果：2,5
分析：a作为右值时，为数组首元素的首地址，故a+1为第二个元素a[1]的地址，*(a+1)为a[1],即2
	  &a为数组的首地址，&a+1为下一个数组的首地址

再次领会a与&a的意义：
如： 
int main()
{
	char a[5]={'A','B','C','D'};
	char (*p3)[5] = &a;
	char (*p4)[5] = a;
	return 0;
}
分析：
	p3 和p4 都是数组指针，指向的是整个数组。其p3和p4都是数组的首地址；
	&a为数组的首地址，a为数组首元素的首地址，，其值相同但意义不同。
	赋值符号“=”号两边的数据类型必须是相同的，如果不同需要显示或隐式的类型转换。
p3 这个定义的“=”号两边的数据类型完全一致，而p4 这个定义的“=”号两边的数据类型就
不一致了。左边的类型是指向整个数组的指针，右边的数据类型是指向单个字符的指针。

#注：编译器并没有为数组a分配一块内存来存其地址，这一点就与指针有很大的差别。
与strlen区别：strlen 函数是计算字符串长度的，并不包含字符串最后的'\0'。

5、
32位的 signed int类型整数其值表示法范围为：-2^31～2^31-1；
一个 32位的 unsigned int类型整数其值表示法范围为：0～ 2^32-1
8 位的char类型数其值表示的范围为-2^7～2^7-1。
8位的unsigned char类型数其值表示的范围为 0～2^8-1

int main()
{
char a[1000]; #默认情况下是有符号的，其表示的值的范围为[-128,127]
int i;
for(i=0; i<1000; i++)
{
    a[i] = -1-i;
}
cout<<strlen(a)<<endl;# 255
return 0;
}
分析：a[0]到a[254]里面的值都不为0，而a[255]的值为'\0'。strlen 函数是计算字符串长度的，并不包含字符串最后的‘\0’。

6、swith正确用法：
switch(variable)
{
	case Value1:
		//program code
		break;
	case Value2:
		//program code
		break;
	case Value3:
		//program code
		break;
	…
	default:
		break;
}
7、const只读变量不分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的值，没有了存储与读内存的操作，使得它的效率也很高。

8、
const int *p; // p 可变，p 指向的对象不可变
int const *p; // p 可变，p 指向的对象不可变
int *const p; // p 不可变，p 指向的对象可变
const int *const p; //指针p 和p 指向的对象都不可变

9、volatile变量————告诉编译器i 是随时可能发生变化的，每次使用它的时候必须从内存中取出i的值
如：
int i=10;
int j = i；//(1)语句
int k = i；//(2)语句
这时候编译器对代码进行优化，因为在（1）、（2）两条语句中，i 没有被用作左值。这时候
编译器认为i 的值没有发生改变，所以在（1）语句时从内存中取出i 的值赋给j 之后，这个
值并没有被丢掉，而是在（2）语句时继续用这个值给k 赋值。编译器不会生成出汇编代码
重新从内存里取i 的值，这样提高了效率
再如：
volatile int i=10;
int j = i；//(3)语句
int k = i；//(4)语句
volatile 关键字告诉编译器i 是随时可能发生变化的，每次使用它的时候必须从内存中取出i
的值，因而编译器生成的汇编代码会重新从i 的地址处读取数据放在k 中。

10、C语言中的extren和C++中的extern 的作用有所不同
C语言中，extern 可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中

11、空结构体的大小就定位1 个byte。

12、union
union 维护足够的空间来置放多个数据成员中的“一种”，在union 中所有的数据成员共用一个空间，同一时间只能储存其中一个数据成员，所有的数据成员具有相同的起始地址。
union StateMachine
{
	char character;
	int number;
	char *str;
	double exp;
};//一个union 只配置一个足够大的空间以来容纳最大长度的数据成员
13、大端小端
大端模式————字数据的高字节存储在低地址中，而字数据的低字节则存放在高地址中。
小端模式————字数据的高字节存储在高地址中，而字数据的低字节则存放在低地址中

14、enum
枚举(enum)感到迷惑，或者认为没什么用，其实枚举(enum)是个很有用的数据类型。
enum enum_type_name类型
{
	ENUM_CONST_1,
	ENUM_CONST_2,
	...
	ENUM_CONST_n
} enum_variable_name变量名;
enum_variable_name 为enum_type_name类型的一个变量，实际上enum_type_name类型是对一个变量取值范围的限定，而花括号内是它的取值范围，
如：
enum Color
{
	GREEN = 1,
	RED,
	BLUE,
	GREEN_RED = 10,
	GREEN_BLUE
}ColorVal；
结果：
	GREEN = 1
	RED = 2
	BLUE = 3
	GREEN_RED = 10
	GREEN_BLUE = 11
注：如果都没有赋值，它们的值从0 开始依次递增1
15、转义字符的意义
#	\n 回车换行
#	\t 横向跳到下一制表位置
#	\v 竖向跳格
#	\b 退格
#	\r 回车
#	\f 走纸换页
#	\\ 反斜扛符"\"
#	\' 单引号符
#	\a 鸣铃
#	\ddd 1～3 位八进制数所代表的字符
#	\xhh 1～2 位十六进制数所代表的字符

16、
1，‘1‘，“1”。
第一个是整形常数，32 位系统下占4 个byte；
第二个是字符常量，占1 个byte；
第三个是字符串常量，占2 个byte。
17、位运算符
	&(都是1)
	|(至少一个1)
	^(只有一个1)

	~ 取反
	<< 左移————高位丢弃，低位补0。
	>> 右移
			————对于有符号数，在右移时，符号位将随同移动。
				当为正数时， 最高位补0；
				当为负数时，符号位为1，最高位是补0 或是补1 取决
于编译系统的规定。
注：左移和右移的位数不能大于数据的长度，不能小于0。
	如：0x01<<2+30；或0x01<<2-3；都是错误的

18、一些优先级容易出错的情况
*p.f 					# .的优先级高于*->操作符用于消除这个问题
int *ap[]				# []高于*
int *fp()				# 函数()高于*
(val & mask != 0)		# == 和!=高于位操作
c = getchar() !=EOF		# == 和!=高于赋值符
msb << 4 + lsb			# 算术运算符高于位移运算符
19、预处理
#define 		宏定义
#undef 			撤销已定义过的宏名
#include 		使编译程序将另一源文件嵌入到带有#include 的源文件中
#if #else #elif #endif 
			#if 的一般含义是如果#if 后面的常量表达式为true，则编译它与#endif 之
			间的代码，否则跳过这些代码。命令#endif 标识一个#if 块的结束。#else
			命令的功能有点象C 语言中的else ，#else 建立另一选择（在# if 失败
			的情况下）。#elif 命令意义与else if 相同，它形成一个if else-if 阶梯状
			语句，可进行多种编译选择。
#ifdef #ifndef 
			用#ifdef 与#ifndef 命令分别表示“如果有定义”及“如果无定义”，是条
			件编译的另一种方法
#line 		改变当前行数和文件名称，它们是在编译程序中预先定义的标识符命令的基本形式如下：
#error 		编译程序时，只要遇到#error 就会生成一个编译错误提示消息，并停止编译
#pragma     为实现时定义的命令，它允许向编译程序传送各种指令例如，编译程序可
			能有一种选择，它支持对程序执行的跟踪。可用#pragma 语句指定一个
			跟踪选择。

ANSI 标准C 还定义了如下几个宏：
	_LINE_ 表示正在编译的文件的行号
	_FILE_ 表示正在编译的文件的名字
	_DATE_ 表示编译时刻的日期字符串，例如： "25 Dec 2007"
	_TIME_ 表示编译时刻的时间字符串，例如： "12:30:55"
	_STDC_ 判断该文件是不是定义成标准C 程序

比较重要的预处理：
#pragma message(“消息文本”) 	它能够在编译信息输出窗口中输出相应的信息，这对于源代码信息的控制是非常重要的。
#pragma pack（）				改变编译器的默认对齐方式
分析：为了访问未对齐的内存，处理器需要作两次内存访问；然而，对齐的内存访问仅需要一次访问。
		缺省情况下，编译器默认将结构、栈中的成员数据进行内存对齐。

#注：字，双字，和四字在自然边界上不需要在内存中对齐。因为字，双字，和四字的自然边界分别是偶数地址，可以被4 整除的地址，和可以被8 整除的地址。
一个字或双字操作数跨越了4 字节边界，或者一个四字操作数跨越了8 字节边界，被认为是未对齐的
如： 
struct TestStruct1
{
	char c1;
	short s;
	char c2;
	int i;
};//sizeof(TestStruct2)为12
	理论上，c1 地址为00000000, s 地址为00000001, c2地址为00000003, i 地址为00000004。
	实际，c1 00000000, s 00000002, c2 00000004, i 00000008，这就是内存对齐而导致的问题。
编译器将未对齐的成员向后移，将每一个都成员对齐到自然边界上，从而也导致了整个结构的尺寸
变大
改进：既达到提高性能的目的，又能节约一点空间
struct TestStruct2
{
	char c1;
	char c2;
	short s;
	int i;
};//sizeof(TestStruct2)为8

使用指令#pragma pack (n)，编译器将按照n 个字节对齐。
使用指令#pragma pack ()，编译器将取消自定义字节对齐方式。

	结构体中，成员对齐有一个重要的条件,即每个成员按自己的方式对齐.也就是说虽然指定了按n 字节对齐（#pragma pack (n)）,
但并不是所有的成员都是以n 字节对齐。其对齐的规则是,每个成员按其类型的对齐参数(通常是这个类型的大小)和指定对齐参数
(这里是n 字节)中较小的一个对齐，，即：min(max(n1,n2..n4), sizeof( item )) 。
经典举例：
	#pragma pack(8)
	struct TestStruct4
	{
	char a;
	long b;
	};///sizeof(TestStruct4)为4,则字节不能跨越4
	struct TestStruct5
	{
	char c;#	1
	TestStruct4 d;#	4
	long long e;#	8
	};///sizeof(TestStruct5)为8，则字节不能跨越8
	#pragma pack()
TestStruct5内存结构：
					ff** **** ffff ffff 
					ffff ffff ffff ffff
附加：
对于数组,比如:char a[3];它的对齐方式和分别写3 个char 是一样的.也就是说它还是按1 个字节对齐.
即使这样，typedef char Array3[3];Array3 这种类型的对齐方式还是按1个字节对齐

20、注意NULL 就是NULL，它被宏定义为0：
即#define NULL 0

21、
--函数指针数组
	char * (*pf[3])(char * p);
--函数指针数组的指针
	char * (*(*pf)[3])(char * p);





















