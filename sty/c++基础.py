0、数的表示：
1字节无符号数：0000 0000 ~ 1111 1111（0——255）
1字节有符号数：1111 1111 ~ 0111 1111 (-128——127),因为 1000 0000没有用到，所有就用来表示-128（理论上，约定在表示范围的正值和负值的量应该平衡）

1、位运算： &(都是1)
			|(至少一个1)
			^(只有一个1)

2、位的左移右移
逻辑移位：
	有符号数：
	无符号数：
算术移位：
	有符号数：
	无符号数：
最权威的解释：https://msdn.microsoft.com/zh-cn/library/336xbhcz.aspx

3、位操作的应用：
	1）一种颜色的表示方式—- 通过DWORD来表示颜色
定义：typedef unsigned long DWORD;
即为一个无符号32位（32机器）长整数，有四个字节，我们从左到右叫他1，2，3，4字节，每一个字节的范围是0～255。第一个字节表示alpha值，即透明度。如果是255，表示不透明，0表示完全透明（看不到），其他分别是R,G,B值。
可通过下列方法获得每个字节的值：
	int A = (int)((DWORD & 0xFF000000) >> 24);
	int R = (int)((DWORD & 0x00FF0000) >> 16);
	int G = (int)((DWORD & 0x0000FF00) >> 8);
	int B = (int)(DWORD & 0x000000FF);

DWORD dwColor = (A<<24)+(R<<16)+(G<<8)+B;
有了前面的基础，我相信大家对上面的换算方法，一看就明白吧。如果对16进制不敏感的童鞋，可以用计算机把十六进制换算成二进制，更容易理解。

	2）状态系统中的使用

在游戏开发中，我们通常用一个32位（假设这里用32位）的整数来存储角色的状态(这样做主要是为了节约存储空间，同时也减小网络同步消息包的size)。所谓的状态，就是大家熟悉的Buff或者DeBuff。
enum ROLE_STATUS
{
	STATUS_NORMAL = 0, // 正常
	STATUS_DIE = 1, // 死亡状态
	STATUS_GOD , // 无敌
	STATUS_DISAPPEARING , // 消失中状态
	STATUS_DEF_ADJUST , // 物理防御提升/降低
	STATUS_MDEF_ADJUST , // 魔法防御提升/降低
	STATUS_ATK_CRI_ADJUST , // 同时提升物理攻击和爆击率
	STATUS_MAXHP_ADJUST , // HP上限调整
	STATUS_MAXMP_ADJUST , // MP上限提升/降低
	//……
	这里最多只能写32个，因为我们假设是用32位数据来存储状态。
};

状态数据定义好了，现在来看看怎么使用他们。
首先， 角色上线，我要给他一个保护状态，应该这样操作。
DWORD dwRoleStatus = STATUS_GOD;
同时，角色使用了一个物品，这个物品的效果时，HP和MP上限增加一段时间。因此要附加调整玩家的HP和MP上限的状态，应该这样。
DWORD dwRoleStatus |= (STATUS_MAXHP_ADJUST+STATUS_MAXMP_ADJUST);
这里是|=而不是=操作，因为不能清掉之前附加的无敌保护状态。所以用或运算。
该角色受到其他玩家或者怪物的攻击，我们要判断被攻击的这个角色的受保护状态状态还在不在。执行如下逻辑
if( dwRoleStatus & STATUS_GOD ) // 判断位是否为1
{
// 受保护状态，不能被攻击
}

接下来，角色无敌保护时间过期了，我们要清除无敌状态，执行如下操作
dwRoleStatus &= ~STATUS_GOD;
这里用到了取反的计算。~STATUS_GOD的结果是第二位为0外，其他都为1。然后和dwRoleStatus做按位与计算。
STATUS_GOD 等于 0000 0000 0000 0000 0000 0000 0000 0000 0000 0010;
~STATUS_GOD 等于 1111 1111 1111 1111 1111 1111 1111 1111 1111 1101;
因此和dwRoleStatus相与之后，dwRoleStatus除了第二位以外的位，都保留下来了。第二位不管是什么值，都会被设置为0,这样子就把STATUS_GOD这个状态清除掉了。同理我们要清除多个状态的时候，先把要清楚的状态或运算到一起。再取反，然后和dwRoleStatus按位与。起到同时清除多个状态。

然后讲讲异或，它有一个性质是，两次异或，能还原回来
例如 a=7,b=6;
a = a^b^b
我们来看看那二进制的操作
a = 0111
b = 0110
c = a^b = 0001
a = c^b = 0111
写到这里，想到一道经典的C++笔试题，即不需要第3个变量，交换两个变量的值。
a = a^b = 0001
b = b^a = 0111
a = a^b = 0110


3、类型转换
最权威的解释：https://msdn.microsoft.com/zh-cn/library/aetzh118.aspx
	整形提升
	整形转换
	浮点转换
	整形和浮点转换
	算术转换
	指针转换
	引用转换
	成员指针的转换

算术转换：把一种算术类型转换成另一种算术类型
	bool变量 = 非bool变量
	非bool变量 = bool变量
	整数类型 = 浮点数（超出、未超出）
	浮点数 = 整数类型（超出、未超出）
	无符号数 = 值
		#————溢出：按无符号的规则处理
		#————未溢出：正常赋值
	有符号数 = 值
		#————溢出：结果未定义
		#————未溢出：正常赋值

只有赋值运算的时候，才有溢出或未溢出。其他运算都是先进行整型提升才能进行下一步算术运算：

整型提升：
	如：表达式里既有有符号类型又有无符号类型，有符号类型会自动转换为无符号类型

5、整形溢出
————对于unsigned整型溢出，C的规范是有定义的——“溢出后的数会以2^(8*sizeof(type))作模运算”，也就是说，如果一个unsigned char（1字符，8bits）溢出了，会把溢出的值与256求模。
————对于signed整型的溢出，C的规范定义是“undefined behavior”，也就是说，编译器爱怎么实现就怎么实现。对于大多数编译器来说，算得啥就是啥。


4、浮点数的二进制表示

5、字符拷贝 与 内存拷贝
