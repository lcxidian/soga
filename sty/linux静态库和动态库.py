-1、对c++中extern的理解
	作用一：当它与"C"一起连用时，如: extern "C" void fun(int a, int b);则告诉编译器在编译fun这个函数名时按着C的规则去翻译相应的函数名而不是C++的，C++的规则在翻译这个函数名时会把fun这个名字变得面目全非
	作用二：用于
	全局变量是在函数的外部定义的，它的作用域为从变量的定义处开始，到本程序文件的末尾，如果全局变量不在文件的开头定义，其有效的作用范围只限于定义处到文件终了。如果在定义点之前的函数想引用该全局变量，则应该在引用之前用关键字 extern对该变量作外部变量声明，表示该变量是一个将在下面定义的全局变量。
	使用：1）使用的函数在其他头文件中时，自需要include该头文件，然后使用即可，并没有加extern，便可以使用该函数了（）（加不加extern都可以）
		2）使用的全局变量在其他头文件中时，自需要include该头文件，然后使用即可，并没有加extern，便可以使用该全局变量了（加不加extern都可以）
		3）使用的函数在本文件下面才定义时(即使用在定义的前面)，就要必须加在使用前extern声明函数
		4）使用的变量在本文件下面才定义时(即使用在定义的前面)，就要必须加在使用前extern声明函数
0、gcc与g++的关联
yum　install gcc
yum install gcc-c++
yum install gdb
未完待续


1、编译过程
源文件(.c、.cpp）———》（编译器、汇编器、链接器）———》可执行文件
	————会经历三个过程：编译、把高级语言转换成汇编语言
					 汇编、把汇编语言转换成机器代码(二进制形式)，也就目标文件,机器代码的生成与处理器有直接关系
					 连接、将多个文件对应的多段机器代码合成一个可执行文件（将代码段和数据段合并，并添加相应的头文件）
2、
	 应用程序（即可执行文件）
	|		|
调用库函数	|
    |		|
	 系统调用
		|
	   内核
注：应用程序很少直接调用系统调用，而是通过库函数实现其功能的

3、可执行文件(无后缀)属于ELF文件格式，其中还要目标文件(*.o)和共享库(*.so)都属于ELf文件格式的
	1）可执行文件(应用程序)
	可执行文件包含了代码和数据,是可以直接运行的程序。
	2）可重定向文件(*.o)
	可重定向文件又称为目标文件,它包含了代码和数据(这些数据是和其他重定位文件和共享的 object 文件一起连接时使用的)。*.o 文件参与程序的连接(创建一个程序)和程序的执行(运行一个程序),它提供了一个方便有效的方法来用并行的视角看待文件的内容,这些*.o 文件的活动可以反映出不同的需要。
	3）共享文件(*.so)
	也称为动态库文件,它包含了代码和数据(这些数据是在连接时候被连接器 ld 和运行时动态连接器使用的)。动态连接器可能称为 ld.so.1,libc.so.1 或者 ld-linux.so.1。我的CentOS6.0 系统中该文件为:/lib/ld-2.12.so
4、库————一种可执行代码的二进制格式。分配静态库(.a)和动态库(.so)
	1) 静态库:这类库的名字一般是 libxxx.a,xxx 为库的名字。利用静态函数库编译成的文件比较大,因为整个函数库的所有数据都会被整合进目标代码中,他的优点就显而易见了,即编译后的执行程序不需要外部的函数库支持,因为所有使用的函数都已经被编译进去了。当然这也会成为他的缺点,因为如果静态函数库改变了,那么你的程序必须重新编译。因此，静态库较适宜于较小的应用程序,因为它们只需要最小限度的函数。
	使用：#当要使用静态的程序库时,连接器会找出程序所需的函数,然后将它们拷贝到执行文件,由于这种拷贝是完整的,所以一旦连接成功,静态程序库也就不再需要了。
	2) 动态库(俗称共享库):这类库的名字一般是 libxxx.M.N.so,同样的 xxx 为库的名字,M 是库的主版本号,N 是库的副版本号。当然也可以不要版本号,但名字必须有。相对于静态函数库,动态函数库在编译的时候并没有被编译进目标代码中,你的程序执行到相关函数时才调用该函数库里的相应函数,因此动态函数库所产生的可执行文件比较小。由于函数库没有被整合进你的程序,而是程序运行时动态的申请并调用,所以程序的运行环境中必须提供相应的库。动态函数库的改变并不影响你的程序,所以动态函数库的升级比较方便。linux 系统有几个重要的目录存放相应的函数库,如/lib /usr/lib  /usr/local/lib。
	使用：#动态库会在执行程序内留下一个标记指明当程序执行时,首先必须载入这个库。由于动态库节省空间,linux 下进行连接的缺省操作是首先连接动态库，而不是静态库

5、制作静态库（编译时被使用)------Cyuyancaiyouxiao
	1) 将源文件编译成目标文件：
		gcc -c test1.cpp test2.cpp
	2) 再将两个目标文件通过归档压缩命令ar生成静态库libmytest.a：这时这个静态库中就包含那两个obj文件了
		ar -rsv libmytest.a test1.o test2.o
	3）使用：
		gcc -o main main.cpp -L./（该静态库路径）-lmytest.a（静态库名）
			#-L 是告诉编译器库文件的路径是当前目录,
			#-l 是告诉编译器要使用的库的名字叫 mytest
	注：在main.cpp文件中，直接使用静态库libmytest.a中的api，不需要添任何头文件
6、制作动态库（运行时被使用）
	1) 将源文件编译成目标文件：
		gcc -c test_a.cpp test_b.cpp test_c.cpp
	2) 将目标文件打包成动态库libmytest.so:
		gcc -shared -fPCI -o libmytest.so test_a.o test_b.o test_c.o
		#-shared 该选项指定生成动态连接库(让连接器生成 T 类型的导出符号表,有时候也生成弱连接 W 类型的导出符号),不用该标志外部程序无法连接。相当于一个可执行文件。
		#-fPIC:表示编译为位置独立的代码,不用此选项的话编译后的代码是位置相关的所以动态载入时是通过代码拷贝的方式来满足不同进程的需要,而不能达到真正代码段共享的目的。
	3）动态链接————执行时加载库(如果它已经在内存中了,则无需再加载)
		先将动态库libmytest.so拷贝到/usr/local/lib/mytest目录中，然后在/etc/ld.so.conf.d目录touch一个mytest.conf文件，并在文件中添加内容：/usr/local/lib/mytest，最后在执行ldconfig命令，使得我们自定义的动态库libmytest在/etc/ld.so.cache中出现
		gcc -o main -L./ -lmytest main.c
		#-ltest”标记来告诉 GCC 驱动程序在连接阶段引用共享函数库 libtest.so
	注： 1）linux的动态链接库配置文件在/etc/ld.so.conf下
		如：
			[root@lcxidian ~]# cat /etc/ld.so.conf
			include ld.so.conf.d/*.conf
			[root@lcxidian ~]# cd /etc/ld.so.conf.d
			[root@lcxidian ld.so.conf.d]# ls
			bind99-i386.conf                 libiscsi-i386.conf
			kernel-4.0.4-301.fc22.i686.conf  llvm-i386.conf
			kernel-4.1.3-200.fc22.i686.conf
			[root@lcxidian ld.so.conf.d]# cd /usr/lib/llvm/
			[root@lcxidian llvm]# ls
			BugpointPasses.so  libLLVM-3.5.so  LLVMgold.so
			libLLVM-3.5.0.so   libLTO.so       readline.so

			同时，我们也可以为boost库touch一个boost-1-58-0.conf,并添加内容：/usr/local/lib，这样就可使用我们的boost库了
			当我们修改/etc/ld.so.conf或/etc/ld.so.conf.d目录内容时，必须执行ldconfig命令，该命令的用途就是搜索/lib 和/usr/lib,以及配置文件/etc/ld.so.conf 里所列的目录下搜索可用的动态链接库文件,然后创建处动态加载程序/lib/ld-linux.so.2 所需要的连接和(默认)缓存文件/etc/ld.so.cache(此文件里保存着已经排好序的动态链接库名字列表)。
		2）动态库基本存放在/lib，/usr/lib，/usr/local/lib下。（当然也可存放在其他路径下，只要在动态链接库配置文件中注明即可）
		3）ldd命令用来查看一个文件都依赖了那些os库


	4）动态加载————先加载一个特定的库(已加载则不必),然后调用该库中的某一特定函数
	   动态加载是非常灵活的,它依赖于一套 Linux 提供的标准 API 来完成。在源程序里,
你可以很自如的运用 API 来加载、使用、释放 so 库资源。这是构建支持插件的应用程序的一个普遍的方法。
	API如下：头文件:dlfcn.h
		const char *dlerror(void) 
			当动态链接库操作函数执行失败时,dlerror 可以返回出错信息,返
		void *dlopen(const char *filename, int flag)
			用于打开指定名字(filename)的动态链接库,并返回操作句柄。
		void *dlsym(void *handle, char *symbol)
			根据动态链接库操作句柄(handle)与符号(symbol),返回符号数。
		int dlclose (void *handle) 
			用于关闭指定句柄的动态链接库,只有当此动态链接库的使用计数为
