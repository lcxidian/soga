==========================

#4、从一个旋转的“有序”数组中查找某个值（有重复值）
输入：有序可重复的旋转数组
输出：目标值的下标
思路：旋转数组的特点：从旋转数组的中间划分开，必定有一半是有序的
		若左半边是有序的，目标值在左半边，则返回目标值的下标，目标值不在左半边，则删除左半边，再重新划分
		若右半边是。。。
#时间复杂度： 

#13、Valid Sudoku
输入：
输出:
时间复杂度： 
思想：
#14、Trapping Rain Water
输入：
输出:
时间复杂度： 
思想：

==========================
#17、Climbing Stairs
输入：
输出:
时间复杂度： 
思想：
#18、Gray Code
输入：
输出:
时间复杂度： 
思想：
==========================
#19、Set Matrix Zeroes
输入：
输出:
时间复杂度： 
思想：
#20、Gas Station
输入：
输出:
时间复杂度： 
思想：

==========================
#10、Copy List with Random Pointer
深拷贝一个链表，链表除了含有next指针外，还包含一个random指针，该指针指向链表中的某个节点或者为空。
输入：
输出：
时间复杂度：
思想：重点在于随机指针的深拷贝，如何保证一个节点不会被创建两次呢？set容器来做到

#3、String to Integer
输入：一个表示数字的字符串，需要考虑不同的输入形式。
输出：换算成对应的整数 
	特殊输入形式：
		1.输入开始几个字符为空格
		2.考虑正负号
		3.数字字符不属于[0,9]时，输出当前结果
		4.字符串代表的数字大于INT_MAX或者小于INT_MIN时输出 INT_MAX或者 INT_MIN。  
时间复杂度：
思想：重点在于数的表示情况分类和整数浮点数范围
	输入字符的类型有数字(0-9)，符号(-、+、.、)，字母(e)
#5、Longest Palindromic Substring
在给出的一个序列中，找到最长的回文字串。譬如：一个序列 cabccba，它的最长回文子串是 abccba。
输入:
输出：
时间复杂度：
思想：
	思路一：暴力枚举，以每个元素为中间元素，同时从左右出发，复杂度O(n2)。
	思路二：记忆化搜索，复杂度O(n2)。设f[i][j] 表示[i,j] 之间的最长回文子串，递推方程

==========================
#6、Regular Expression Matching
实现支持 ' . '和 ' * '的正则表达式。（' . ' 匹配任何单字符。' * '匹配0或多个前向元素。）
输入:
	isMatch("aa","a") → false
	isMatch("aa","aa") → true
	isMatch("aaa","aa") → false
	isMatch("aa", "a*") → true
	isMatch("aa", ".*") → true
	isMatch("ab", ".*") → true
	isMatch("aab", "c*a*b") → true
	isMatch("abc",".fdsfs*")->false
输出：
时间复杂度：
思想：
==========================
#7、Wildcard Matching
Implement wildcard pattern matching with support for  '?'  and  '*'
输入:
	isMatch("aa","a") → false
	isMatch("aa","aa") → true
	isMatch("aaa","aa") → false
	isMatch("aa", "*") → true
	isMatch("aa", "a*") → true
	isMatch("ab", "?*") → true
	isMatch("aab", "c*a*b") → false
输出：
时间复杂度：
思想：主要是'*' 的匹配问题。p 每遇到一个'*'，就保留住当前'*' 的坐标和s 的坐标，然后s 从前
		往后扫描，如果不成功，则s++，重新扫描。
==========================
#8、最长公共子串
输入:
输出：
时间复杂度：
思想：
==========================
#9、Valid Number
输入:
	"0" => true
	" 0.1 " => true
	"abc" => false
	"1 a" => false
	"2e10" => true 
输出：
时间复杂度：
思想：信息分类：0-9
				.
				e

#10、Integer to Roman
阿拉伯数字和罗马数字之间的转换
	罗马数字规则：
		1， 罗马数字共有7个，即I（1）、V（5）、X（10）、L（50）、C（100）、D（500）和M（1000）。
		罗马数字中没有“0”。
		2， 重复次数：一个罗马数字最多重复3次。
		3， 右加左减：
		在较大的罗马数字的右边记上较小的罗马数字，表示大数字加小数字。
		在较大的罗马数字的左边记上较小的罗马数字，表示大数字减小数字。
		4， 左减的数字有限制，仅限于I、X、C，且放在大数的左边只能用一个。
		(*) V 和 X 左边的小数字只能用Ⅰ。
		(*) L 和 C 左边的小数字只能用X。
		(*) D 和 M 左 边的小数字只能用C。
输入:
输出：
时间复杂度：
思想：
#11、Roman to Integer
输入:
输出：
时间复杂度：
思想：从前往后扫描，用一个临时变量记录分段数字。
		如果当前比前一个大，说明这一段的值应该是当前这个值减去上一个值。比如IV = 5 – 1；否
		则，将当前值加入到结果中，然后开始下一段记录。比如VI = 5 + 1, II=1+1
